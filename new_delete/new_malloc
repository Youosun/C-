new与malloc的10点区别：
1、申请的内存所在的位置不同
	new 操作符从自由存储区(free store)上为对象动态分配内存空间
	malloc从堆上动态分配内存

	自由存储区---凡是通过new操作符进行内存申请，该内存即为自由存储区
	堆---操作系统维护的一块特殊内存，用于程序的内存动态分配

	自由存储区不仅可以是堆，还可以是静态存储区，具体取决于new在哪里为对象分配内存

2、返回类型的安全性

	new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换。
		所以new是符合类型安全性的操作符
	malloc返回的是void*，需要进行强制类型转换成我们需要的类型

    而类型安全性很大程度上等价于内存安全性，类型安全的代码不会访问自己没被授权的内存区域

3、内存分配失败时的返回值
	new内存分配失败时，抛出bac_alloc的异常，不返回NULL，使用C++异常机制捕获异常
	malloc分配内存失败时返回NULL，自己手动判断分析

4、是否需要制定内存大小
	new操作符申请内存分配时无需制定内存块的大小，编译器根据类型信息自行计算
	malloc 则需要显式地指出所需内存的尺寸

5、是否调用构造函数、析构函数
	new操作符
	A、调用operator new函数(对于数组是operator new []) 分配一块足够大的、原始的、未命名的内存空间，以便存储特定类型的对象。
	B、编译器运行相应的构造函数以构造对象，并为其传入初值---申请即可被初始化
	C、对象构造完成后，返回指向该对象的指针

	delete操作符释放对象内存时
	A、调用对象的析构函数
	B、编译器调用operator delete(operator delete []) 函数释放内存空间
	
	malloc和free并没有相应的处理---需要手动初始化值

6、对于数组的处理
	new []/delete [] 专门处理数组类型  配套使用  防止内存泄漏

	malloc/free并不关心内存上存放的类型 --- 动态分配数组大小需手动定义

7、new与malloc是否可以相互调用
	new /delete的实现可以基于malloc/free
	而malloc的实现不可以调用new

8、是否可以进行重载
	new/delete 操作符可以重载
	malloc/free 不允许重载

9、能否直观的重新分配内存
	malloc分配的内存在使用过程中发现内存不足时，可以使用realloc函数进行内存重新分配实现内存的扩充
		realloc先判断当前的指针指向的内存是否有连续的内存空间：
			如果有，原地址扩大可分配的内存地址，返回原来的地址指针
			如果空间不够，先按照指定的大小分配空间，将原有数据重新拷贝到新分配的内存区域，而后释放原来的内存区域

	new没有直观的配套设施来扩充内存

10、new在内存大小未获得满足前抛出异常，在抛出异常之前调用用户指定的错误处理函数，new_handler.
	new_handler是一个函数指针类型
	namespace std
	{
		typedef void (*new_handler)();
	}
	指针指向了没有参数没有返回值的函数，即错误处理函数。
	用户可以调用set_new_handler，指定错误处理函数
	namespace std
	{
		new_handler set_new_handler(new_handler p) throw();
	}

	对于malloc 并不能决定内存不足时要怎么做，只能看到malloc返回NULL




最后:
malloc给你的就像是一块原始的土地，需要什么自己种

new帮你划好了田地的分块(数组),帮你播了种(构造函数构造出对象并初始化),还有其他的设施使用
